// Sparse matrix

#include <iostream>
#include <vector>
#include <map>
#include <utility>

using namespace std;

#define MAX 100

class Sparse
{
public:
    int a[MAX][MAX];
    int s[MAX][3]; 
    int r = 0, c = 0, nz = 0;

    void read();
    void convert();
    void display();
    Sparse transpose() const;
};

void Sparse::read()
{
    cout << "Enter dimensions of matrix (rows cols): ";
    cin >> r >> c;
    cout << "Enter values (row-major, " << r << "x" << c << "):\n";
    for (int i = 0; i < r; ++i)
        for (int j = 0; j < c; ++j)
            cin >> a[i][j];
}

void Sparse::convert()
{
    s[0][0] = r;
    s[0][1] = c;
    int k = 1;
    for (int i = 0; i < r; ++i)
    {
        for (int j = 0; j < c; ++j)
        {
            if (a[i][j] != 0)
            {
                s[k][0] = i;
                s[k][1] = j;
                s[k][2] = a[i][j];
                ++k;
            }
        }
    }
    s[0][2] = k - 1;
    nz = s[0][2];
}

void Sparse::display()
{
    cout << "Triplet (row col val), header = (rows cols nz):\n";
    for (int i = 0; i <= nz; ++i)
    {
        cout << s[i][0] << " " << s[i][1] << " " << s[i][2] << "\n";
    }
}


Sparse Sparse::transpose() const
{
    Sparse t;
    // header
    t.s[0][0] = s[0][1];
    t.s[0][1] = s[0][0];
    t.s[0][2] = s[0][2];
    t.r = t.s[0][0];
    t.c = t.s[0][1];
    t.nz = t.s[0][2];

    int k = 1;
    for (int i = 1; i <= nz; ++i)
    {
        t.s[k][0] = s[i][1];
        t.s[k][1] = s[i][0];
        t.s[k][2] = s[i][2];
        ++k;
    }
    return t;
}

Sparse add(const Sparse &s1, const Sparse &s2)
{
    Sparse sum;
    if (s1.r != s2.r || s1.c != s2.c)
    {
        cerr << "Error: matrix dimensions must match for addition.\n";
        return sum;
    }

    sum.s[0][0] = sum.r = s1.r;
    sum.s[0][1] = sum.c = s1.c;

    int i = 1, j = 1, k = 1;
    while (i <= s1.nz && j <= s2.nz)
    {
        int r1 = s1.s[i][0], c1 = s1.s[i][1];
        int r2 = s2.s[j][0], c2 = s2.s[j][1];

        if (r1 == r2 && c1 == c2)
        {
            int val = s1.s[i][2] + s2.s[j][2];
            if (val != 0)
            {
                sum.s[k][0] = r1;
                sum.s[k][1] = c1;
                sum.s[k][2] = val;
                ++k;
            }
            ++i; ++j;
        }
        else if (r1 < r2 || (r1 == r2 && c1 < c2))
        {
            sum.s[k][0] = r1;
            sum.s[k][1] = c1;
            sum.s[k][2] = s1.s[i][2];
            ++k; ++i;
        }
        else
        {
            sum.s[k][0] = r2;
            sum.s[k][1] = c2;
            sum.s[k][2] = s2.s[j][2];
            ++k; ++j;
        }
    }

    while (i <= s1.nz)
    {
        sum.s[k][0] = s1.s[i][0];
        sum.s[k][1] = s1.s[i][1];
        sum.s[k][2] = s1.s[i][2];
        ++k; ++i;
    }
    while (j <= s2.nz)
    {
        sum.s[k][0] = s2.s[j][0];
        sum.s[k][1] = s2.s[j][1];
        sum.s[k][2] = s2.s[j][2];
        ++k; ++j;
    }

    sum.nz = sum.s[0][2] = k - 1;
    return sum;
}

Sparse multiply(const Sparse &A, const Sparse &B)
{
    Sparse product;
    if (A.c != B.r)
    {
        cerr << "Error: incompatible dimensions for multiplication (A.cols must == B.rows).\n";
        return product;
    }

    product.r = product.s[0][0] = A.r;
    product.c = product.s[0][1] = B.c;

    // Using map here instead of an array so we don't need to manually add values later, it can be done while iterating.
    map<pair<int,int>, int> accum;
    for (int i = 1; i <= A.nz; ++i)
    {
        for (int j = 1; j <= B.nz; ++j)
        {
            if (A.s[i][1] == B.s[j][0])
            {
                int r = A.s[i][0];
                int c = B.s[j][1];
                int v = A.s[i][2] * B.s[j][2];
                accum[make_pair(r,c)] += v;
            }
        }
    }

    // convert map to triplet list
    int k = 1;
    for (auto &entry : accum)
    {
        if (entry.second != 0)
        {
            product.s[k][0] = entry.first.first;
            product.s[k][1] = entry.first.second;
            product.s[k][2] = entry.second;
            ++k;
        }
    }
    product.nz = product.s[0][2] = k - 1;
    return product;
}

Sparse ftranspose(const Sparse &s)
{
    Sparse res;
    res.r = res.s[0][0] = s.c;
    res.c = res.s[0][1] = s.r;
    res.nz = res.s[0][2] = s.nz;

    if (s.nz == 0) return res;

    vector<int> freq(s.c, 0);
    vector<int> cumfreq(s.c, 0);

    for (int i = 1; i <= s.nz; ++i)
        ++freq[s.s[i][1]];

    cumfreq[0] = 1;
    for (int i = 1; i < s.c; ++i)
        cumfreq[i] = cumfreq[i-1] + freq[i-1];

    for (int i = 1; i <= s.nz; ++i)
    {
        int col = s.s[i][1];
        int loc = cumfreq[col];
        res.s[loc][0] = s.s[i][1];
        res.s[loc][1] = s.s[i][0];
        res.s[loc][2] = s.s[i][2];
        ++cumfreq[col];
    }
    return res;
}

int main()
{
    int choice = 0;
    Sparse s1, s2;

    while (choice != 7)
    {
        cout << "\nMenu:\n"
             << "1 - Read and convert Matrix A\n"
             << "2 - Read and convert Matrix B\n"
             << "3 - Display A and B (sparse)\n"
             << "4 - Add A + B\n"
             << "5 - Multiply A * B\n"
             << "6 - Transpose A (simple) and fast-transpose A\n"
             << "7 - Exit\n"
             << "Enter choice: ";
        cin >> choice;

        switch (choice)
        {
        case 1:
            s1.read();
            s1.convert();
            cout << "A converted.\n";
            break;
        case 2:
            s2.read();
            s2.convert();
            cout << "B converted.\n";
            break;
        case 3:
            cout << "Matrix A (sparse):\n";
            s1.display();
            cout << "Matrix B (sparse):\n";
            s2.display();
            break;
        case 4:
        {
            Sparse sum = add(s1, s2);
            cout << "A + B (sparse):\n";
            sum.display();
            break;
        }
        case 5:
        {
            Sparse prod = multiply(s1, s2);
            cout << "A * B (sparse):\n";
            prod.display();
            break;
        }
        case 6:
        {
            cout << "Simple transpose of A:\n";
            Sparse t = s1.transpose();
            t.display();
            cout << "Fast transpose of A:\n";
            Sparse ft = ftranspose(s1);
            ft.display();
            break;
        }
        case 7:
            cout << "Exiting.\n";
            break;
        default:
            cout << "Invalid choice.\n";
            break;
        }
    }

    return 0;
}


How to convert from infix to postfix using stack

iterate over all characters from left to right
if operand append to result
if ( push to stack
if ) pop stack until ( is found and append all to result
if operator, pop stack until lower precedence operator is found 
append those lower precedence operators to result and push the current operator to stack
at end pop any remaining operators



Convert postfix to infix

iterate from left to right
if operand push to stack
if operator pop a and b from stack and push (a+b) to stack
repeat
final expression is at top of stack


Convert infix to prefix

Reverse infix expression
swap opening and closing parentheses
convert this to postfix
reverse the postfix expression


convert prefix to infix

scan right to left
if operand push to stack
if operator pop a and b from stack and push (a operator b) to stack
done



// Sudoku


#include <bits/stdc++.h>
using namespace std;

bool ok(int g[4][4], int r, int c, int v){
    for(int i=0;i<4;i++){
        if(g[r][i]==v || g[i][c]==v) return false;
    }
    int sr=r/2*2, sc=c/2*2;
    for(int i=0;i<2;i++) for(int j=0;j<2;j++)
        if(g[sr+i][sc+j]==v) return false;
    return true;
}

bool solve(int g[4][4], int r=0, int c=0){
    if(r==4) return true;
    int nr=r, nc=c+1;
    if(nc==4){ nc=0; nr++; }
    if(g[r][c]!=0) return solve(g,nr,nc);
    for(int v=1;v<=4;v++){
        if(ok(g,r,c,v)){
            g[r][c]=v;
            if(solve(g,nr,nc)) return true;
            g[r][c]=0;
        }
    }
    return false;
}

int main(){
    int g[4][4]={
        {1,0,0,0},
        {0,0,0,0},
        {0,3,0,0},
        {2,0,0,0}
    };

    cout<<"Example:\n";
    for(int i=0;i<4;i++){
        for(int j=0;j<4;j++) cout<<g[i][j]<<" ";
        cout<<"\n";
    }

    int s[4][4];
    memcpy(s,g,sizeof(g));
    cout<<"\nSolution:\n";
    if(solve(s)){
        for(int i=0;i<4;i++){
            for(int j=0;j<4;j++) cout<<s[i][j]<<" ";
            cout<<"\n";
        }
    } else cout<<"No solution";
}



//Searchign sorting

#include <iostream>
#include <vector>
#include <tuple>

using namespace std;

#define N 10

class Student{
	public:
	int roll;
	string name;
	string dept;
	float sgpa;
	
	Student(){}
	
	Student(string name, int roll, string dept, float sgpa){
		this->name = name;
		this->roll = roll;
		this->dept = dept;
		this->sgpa = sgpa;
	}
};

void sort_roll(Student students[]){
	// Bubble sort
	bool swapped;
    do{
        swapped = false;
        for (int i = 1; i < N; i++){
            if (students[i-1].roll > students[i].roll){
                swap(students[i-1], students[i]);
                swapped = true;
        	}
		}
    }while(!swapped);
}

void sort_name(Student students[]){
	// Insertion sort
	int i = 1;
	while (i < N){
	    int j = i;
	    while (j > 0 && students[j-1].name > students[j].name){
	        swap(students[j], students[j-1]);
	        j--;
	    }
	    i++;
	}
}

void sort_sgpa(Student students[]){
	// Quick sort
	
}
int search_sgpa(Student students[], float sgpa){
	// Linear Search, returns first occurence
	vector<int> matches;
	for(int i = 0; i < N; i++){
		if(students[i].sgpa == sgpa){
			return i;
		}
	}
	return -1;
}

int search_name(Student students[], string name){
	// Binary search, assumes sorted array, returns first occurence
    int start = 0, end = N, mid;
	do{
		mid = (start + end) / 2;
		if(students[mid].name < name) end = mid - 1;
		else if(students[mid].name > name) start = mid + 1;
		else {
			while(students[mid].name == name) mid--;
			return mid;
		}
	}while(start <= end);
	return -1;
}

void print_students(const Student students[]) {
    cout << "Roll No\tName\tDept\tSGPA" << endl;
    for (int i = 0; i < N; i++) {
        cout << students[i].roll << "\t" << students[i].name << "\t" << students[i].dept << "\t" << students[i].sgpa << endl;
    }
}

void print_students(const Student students[], int n) {
    cout << "Roll No\tName\tDept\tSGPA" << endl;
    for (int i = 0; i < n; i++) {
        cout << students[i].roll << "\t" << students[i].name << "\t" << students[i].dept << "\t" << students[i].sgpa << endl;
    }
}

int main(){
	Student students[N] = {
        Student("Alice", 1005, "CSE", 8.5),
        Student("Bob", 1012, "ECE", 7.8),
        Student("Charlie", 1001, "ME", 9.2),
        Student("David", 1010, "CSE", 7.6),
        Student("Eve", 1003, "IT", 8.9),
        Student("Frank", 1004, "CSE", 6.5),
        Student("Grace", 1006, "CSE", 8.0),
        Student("Heidi", 1008, "ECE", 9.0),
        Student("Ivan", 1013, "IT", 8.2),
        Student("Judy", 1007, "ME", 7.4)
    };
    
    print_students(students);
    
    sort_roll(students);
    print_students(students);
    
    sort_name(students);
    cout << "------Alphabetically-------" << endl;
    print_students(students);
    
    sort_sgpa(students);
    cout << "--------Top 10 SGPA-------" << endl;
    print_students(students, 10);
    
    
}



#include <iostream>
#include <string>
#include <iomanip>
#include <vector>

using namespace std;

class Process {
public:
    int pid;
    string name;
    int burst_time;
    int remaining_time;
    int arrival_time;
    int waiting_time;
    int turnaround_time;
    Process* next;

    Process(int id, string pname, int burst, int arrival = 0) {
        pid = id;
        name = pname;
        burst_time = burst;
        remaining_time = burst;
        arrival_time = arrival;
        waiting_time = 0;
        turnaround_time = 0;
        next = nullptr;
    }

    void display() const {
        cout << setw(5) << pid << setw(15) << name << setw(10) << burst_time 
             << setw(15) << remaining_time << setw(10) << waiting_time 
             << setw(15) << turnaround_time << endl;
    }
};

class CircularQueue {
private:
    Process* front;
    Process* rear;
    int size;
    int time_quantum;

public:
    CircularQueue(int quantum = 2) {
        front = rear = nullptr;
        size = 0;
        time_quantum = quantum;
    }

    ~CircularQueue() {
        while (!isEmpty()) {
            dequeue();
        }
    }

    bool isEmpty() const {
        return front == nullptr;
    }

    int getSize() const {
        return size;
    }

    void setTimeQuantum(int quantum) {
        time_quantum = quantum;
    }

    int getTimeQuantum() const {
        return time_quantum;
    }

    void enqueue(Process* process) {
        if (isEmpty()) {
            front = rear = process;
            rear->next = front; // Circular link
        } else {
            rear->next = process;
            rear = process;
            rear->next = front; // Circular link
        }
        size++;
    }

    Process* dequeue() {
        if (isEmpty()) {
            return nullptr;
        }

        Process* temp = front;
        
        if (front == rear) {
            // Only one element
            front = rear = nullptr;
        } else {
            front = front->next;
            rear->next = front; // Maintain circular link
        }
        
        size--;
        temp->next = nullptr;
        return temp;
    }

    Process* peek() const {
        return front;
    }

    void rotate() {
        if (!isEmpty() && front != rear) {
            front = front->next;
            rear = rear->next;
        }
    }

    void displayQueue() const {
        if (isEmpty()) {
            cout << "Queue is empty!" << endl;
            return;
        }

        cout << "\nCurrent Queue Status:" << endl;
        cout << setw(5) << "PID" << setw(15) << "Name" << setw(10) << "Burst" 
             << setw(15) << "Remaining" << setw(10) << "Waiting" 
             << setw(15) << "Turnaround" << endl;
        cout << string(75, '-') << endl;

        Process* current = front;
        do {
            current->display();
            current = current->next;
        } while (current != front);
    }

    vector<Process*> getAllProcesses() const {
        vector<Process*> processes;
        if (isEmpty()) return processes;

        Process* current = front;
        do {
            processes.push_back(current);
            current = current->next;
        } while (current != front);

        return processes;
    }
};

class RoundRobinScheduler {
private:
    CircularQueue ready_queue;
    vector<Process*> completed_processes;
    int current_time;

public:
    RoundRobinScheduler(int quantum = 2) : ready_queue(quantum), current_time(0) {}

    void addProcess(int pid, string name, int burst_time, int arrival_time = 0) {
        Process* new_process = new Process(pid, name, burst_time, arrival_time);
        ready_queue.enqueue(new_process);
        cout << "Process '" << name << "' added to the ready queue." << endl;
    }

    void executeTimeSlice() {
        if (ready_queue.isEmpty()) {
            cout << "No processes in the ready queue!" << endl;
            return;
        }

        Process* current_process = ready_queue.peek();
        cout << "\n--- Executing Time Slice ---" << endl;
        cout << "Current Time: " << current_time << endl;
        cout << "Executing Process: " << current_process->name 
             << " (PID: " << current_process->pid << ")" << endl;

        int execution_time = min(ready_queue.getTimeQuantum(), current_process->remaining_time);
        
        cout << "Execution time for this slice: " << execution_time << " units" << endl;
        
        current_process->remaining_time -= execution_time;
        current_time += execution_time;

        // Update waiting times for other processes
        Process* temp = ready_queue.peek()->next;
        while (temp != ready_queue.peek()) {
            if (temp->remaining_time > 0) {
                temp->waiting_time += execution_time;
            }
            temp = temp->next;
        }

        if (current_process->remaining_time <= 0) {
            // Process completed
            current_process->turnaround_time = current_time - current_process->arrival_time;
            Process* completed = ready_queue.dequeue();
            completed_processes.push_back(completed);
            cout << "Process '" << completed->name << "' completed execution!" << endl;
        } else {
            // Process not completed, rotate the queue
            cout << "Process '" << current_process->name << "' still has " 
                 << current_process->remaining_time << " units remaining." << endl;
            ready_queue.rotate();
        }
    }

    void executeUntilCompletion() {
        if (ready_queue.isEmpty()) {
            cout << "No processes to execute!" << endl;
            return;
        }

        cout << "\n--- Executing All Processes Until Completion ---" << endl;
        int iterations = 0;
        const int MAX_ITERATIONS = 1000; // Safety limit

        while (!ready_queue.isEmpty() && iterations < MAX_ITERATIONS) {
            executeTimeSlice();
            iterations++;
        }

        if (iterations >= MAX_ITERATIONS) {
            cout << "Warning: Maximum iterations reached!" << endl;
        }

        cout << "\nAll processes completed execution!" << endl;
    }

    void displayStatistics() const {
        cout << "\n=== SCHEDULING STATISTICS ===" << endl;
        
        if (!completed_processes.empty()) {
            cout << "\nCompleted Processes:" << endl;
            cout << setw(5) << "PID" << setw(15) << "Name" << setw(10) << "Burst" 
                 << setw(10) << "Waiting" << setw(15) << "Turnaround" << endl;
            cout << string(60, '-') << endl;

            double total_waiting = 0, total_turnaround = 0;

            for (const auto& process : completed_processes) {
                process->display();
                total_waiting += process->waiting_time;
                total_turnaround += process->turnaround_time;
            }

            cout << "\nAverage Waiting Time: " << total_waiting / completed_processes.size() << endl;
            cout << "Average Turnaround Time: " << total_turnaround / completed_processes.size() << endl;
        }

        if (!ready_queue.isEmpty()) {
            cout << "\nRemaining Processes in Ready Queue:" << endl;
            ready_queue.displayQueue();
        }
    }

    void displayCurrentState() const {
        cout << "\n=== CURRENT SYSTEM STATE ===" << endl;
        cout << "Current Time: " << current_time << endl;
        cout << "Time Quantum: " << ready_queue.getTimeQuantum() << endl;
        cout << "Processes in ready queue: " << ready_queue.getSize() << endl;
        cout << "Completed processes: " << completed_processes.size() << endl;
        
        if (!ready_queue.isEmpty()) {
            ready_queue.displayQueue();
        }
        
        if (!completed_processes.empty()) {
            cout << "\nCompleted Processes:" << endl;
            cout << setw(5) << "PID" << setw(15) << "Name" << setw(10) << "Burst" 
                 << setw(10) << "Waiting" << setw(15) << "Turnaround" << endl;
            cout << string(60, '-') << endl;
            
            for (const auto& process : completed_processes) {
                process->display();
            }
        }
    }

    void clearAllProcesses() {
        while (!ready_queue.isEmpty()) {
            delete ready_queue.dequeue();
        }
        
        for (auto process : completed_processes) {
            delete process;
        }
        completed_processes.clear();
        
        current_time = 0;
        cout << "All processes cleared from the system." << endl;
    }

    void setTimeQuantum(int quantum) {
        ready_queue.setTimeQuantum(quantum);
        cout << "Time quantum set to " << quantum << " units." << endl;
    }
};

void displayMenu() {
    cout << "\n=== ROUND ROBIN SCHEDULER ===" << endl;
    cout << "1. Add Process" << endl;
    cout << "2. Execute Single Time Slice" << endl;
    cout << "3. Execute Until Completion" << endl;
    cout << "4. Display Current State" << endl;
    cout << "5. Display Statistics" << endl;
    cout << "6. Set Time Quantum" << endl;
    cout << "7. Clear All Processes" << endl;
    cout << "8. Exit" << endl;
    cout << "Choose an option: ";
}

int main() {
    RoundRobinScheduler scheduler;
    int choice;
    int pid_counter = 1;

    cout << "=== ROUND ROBIN SCHEDULING SIMULATOR ===" << endl;
    cout << "Using Circular Queue implemented with Linked List" << endl;

    while (true) {
        displayMenu();
        cin >> choice;

        switch (choice) {
            case 1: {
                string name;
                int burst_time, arrival_time;
                
                cout << "Enter process name: ";
                cin >> name;
                cout << "Enter burst time: ";
                cin >> burst_time;
                cout << "Enter arrival time (default 0): ";
                cin >> arrival_time;
                
                scheduler.addProcess(pid_counter++, name, burst_time, arrival_time);
                break;
            }
            
            case 2:
                scheduler.executeTimeSlice();
                break;
            
            case 3:
                scheduler.executeUntilCompletion();
                break;
            
            case 4:
                scheduler.displayCurrentState();
                break;
            
            case 5:
                scheduler.displayStatistics();
                break;
            
            case 6: {
                int quantum;
                cout << "Enter new time quantum: ";
                cin >> quantum;
                scheduler.setTimeQuantum(quantum);
                break;
            }
            
            case 7:
                scheduler.clearAllProcesses();
                pid_counter = 1; // Reset PID counter
                break;
            
            case 8:
                cout << "Exiting Round Robin Scheduler. Goodbye!" << endl;
                return 0;
            
            default:
                cout << "Invalid choice! Please try again." << endl;
        }
    }

    return 0;
}




#include <iostream>
using namespace std;
#define MAX 10

class InputRestrictedDeque {
    int arr[MAX];
    int front, rear;
    
public:
    InputRestrictedDeque() {
        front = -1;
        rear = -1;
    }
    
    bool isFull() {
        return ((front == 0 && rear == MAX - 1) || (front == rear + 1));
    }
    
    bool isEmpty() {
        return (front == -1);
    }
    
    void insertRear(int custID) {
        if (isFull()) {
            cout << "Mall is full.\n";
            return;
        }
        if (front == -1) {
            front = 0;
            rear = 0;
        } else if (rear == MAX - 1)
            rear = 0;
        else
            rear = rear + 1;
            
        arr[rear] = custID;
        cout << "Customer " << custID << " entered from rear gate.\n";
    }
    
    // Can delete from both ends (Output not restricted)
    void deleteFront() {
        if (isEmpty()) {
            cout << "No customers in the mall.\n";
            return;
        }
        cout << "Customer " << arr[front] << " exited from front gate.\n";
        if (front == rear) {
            front = -1;
            rear = -1;
        } else if (front == MAX - 1)
            front = 0;
        else
            front = front + 1;
    }
    
    void deleteRear() {
        if (isEmpty()) {
            cout << "No customers.\n";
            return;
        }
        cout << "Customer " << arr[rear] << " exited from rear gate.\n";
        if (front == rear) {
            front = -1;
            rear = -1;
        } else if (rear == 0)
            rear = MAX - 1;
        else
            rear = rear - 1;
    }
    
    void display() {
        if (isEmpty()) {
            cout << "Mall empty.\n";
            return;
        }
        cout << "Customers: ";
        int i = front;
        while (true) {
            cout << arr[i] << " ";
            if (i == rear)
                break;
            i = (i + 1) % MAX;
        }
        cout << endl;
    }
};

int main() {
    InputRestrictedDeque mall;
    int choice, id;
    
    cout << "Input restricted shopping mall:\n";
    
    do {
        cout << "\n1. Enter from rear\n";
        cout << "2. Exit from front\n";
        cout << "3. Exit from rear\n";
        cout << "4. Display customers\n";
        cout << "5. Exit\n";
        cout << "Enter your choice: ";
        cin >> choice;
        
        switch (choice) {
            case 1:
                cout << "Enter Customer ID: ";
                cin >> id;
                mall.insertRear(id);
                break;
            case 2:
                mall.deleteFront();
                break;
            case 3:
                mall.deleteRear();
                break;
            case 4:
                mall.display();
                break;
            case 5:
                cout << "Exiting\n";
                break;
            default:
                cout << "Invalid choice\n";
        }
    } while (choice != 5);
    
    return 0;
}






#include <iostream>
using namespace std;
#define MAX 10

class OutputRestrictedDeque {
    int arr[MAX];
    int front, rear;
    
public:
    OutputRestrictedDeque() {
        front = -1;
        rear = -1;
    }
    
    bool isFull() {
        return ((front == 0 && rear == MAX - 1) || (front == rear + 1));
    }
    
    bool isEmpty() {
        return (front == -1);
    }
    
    void insertFront(int custID) {
        if (isFull()) {
            cout << "Mall is full";
            return;
        }
        if (front == -1) {
            front = 0;
            rear = 0;
        } else if (front == 0)
            front = MAX - 1;
        else
            front = front - 1;
            
        arr[front] = custID;
        cout << "Customer " << custID << " entered from front gate.\n";
    }
    
    void insertRear(int custID) {
        if (isFull()) {
            cout << "Mall is full\n";
            return;
        }
        if (front == -1) {
            front = 0;
            rear = 0;
        } else if (rear == MAX - 1)
            rear = 0;
        else
            rear = rear + 1;
            
        arr[rear] = custID;
        cout << "Customer " << custID << " entered from rear gate.\n";
    }
    
    void deleteFront() {
        if (isEmpty()) {
            cout << "Mall empty\n";
            return;
        }
        cout << "Customer " << arr[front] << " exited from rear gate.\n";
        if (front == rear) {
            front = -1;
            rear = -1;
        } else if (front == MAX - 1)
            front = 0;
        else
            front = front + 1;
    }
    
    void display() {
        if (isEmpty()) {
            cout << "Mall is empty\n";
            return;
        }
        cout << "Customers: ";
        int i = front;
        while (true) {
            cout << arr[i] << " ";
            if (i == rear)
                break;
            i = (i + 1) % MAX;
        }
        cout << endl;
    }
};

int main() {
    OutputRestrictedDeque mall;
    int choice, id;
    
    cout << "Output restricted Shopping mall\n";
    
    do {
        cout << "\n1. Enter from front\n";
        cout << "2. Enter from rear\n";
        cout << "3. Exit from front\n";
        cout << "4. Display customers\n";
        cout << "5. Exit\n";
        cout << "Enter choice: ";
        cin >> choice;
        
        switch (choice) {
            case 1:
                cout << "Enter Customer ID: ";
                cin >> id;
                mall.insertFront(id);
                break;
            case 2:
                cout << "Enter Customer ID: ";
                cin >> id;
                mall.insertRear(id);
                break;
            case 3:
                mall.deleteFront();
                break;
            case 4:
                mall.display();
                break;
            case 5:
                cout << "Exiting\n";
                break;
            default:
                cout << "Invalid choice\n";
        }
    } while (choice != 5);
    
    return 0;
}






#include <iostream>
#include <vector>
using namespace std;

class HashTableLinear {
private:
    vector<int> table;
    int size;
    vector<bool> occupied;

public:
    HashTableLinear(int tableSize) {
        size = tableSize;
        table.resize(size, -1);
        occupied.resize(size, false);
    }

    int hashFunction(int key) {
        return key % 6;
    }

    void insert(int key) {
        int index = hashFunction(key);
        int originalIndex = index;
        
        while (occupied[index]) {
            index = (index + 1) % size;
            if (index == originalIndex) {
                cout << "Hash table full" << endl;
                return;
            }
        }
        
        table[index] = key;
        occupied[index] = true;
        cout << "Inserted " << key << " at position " << index << endl;
    }

    void display() {
        cout << "\nHash table:" << endl;
        cout << "Index Value Status" << endl;
        for (int i = 0; i < size; i++) {
            cout << i << " ";
            if (occupied[i]) {
                cout << table[i];
            } else {
                cout << "Empty";
            }
            cout << " " << (occupied[i] ? "Occupied" : "Empty") << endl;
        }
    }
};

int main() {
    HashTableLinear ht(6);
    
    cout << "Cold drink flavours, linear probing" << endl;
    
    int flavors[] = {101, 205, 312, 418, 523, 101, 634};
    int n = sizeof(flavors) / sizeof(flavors[0]);
    
    for (int i = 0; i < n; i++) {
        ht.insert(flavors[i]);
    }
    
    ht.display();
    
    return 0;
}





#include <iostream>
#include <vector>
using namespace std;

class HashTableQuadratic {
private:
    vector<int> table;
    int size;
    vector<bool> occupied;

public:
    HashTableQuadratic(int tableSize) {
        size = tableSize;
        table.resize(size, -1);
        occupied.resize(size, false);
    }

    int hashFunction(int key) {
        return key % 11;
    }

    void insert(int key) {
        int index = hashFunction(key);
        int originalIndex = index;
        int i = 0;
        
        while (occupied[index]) {
            i++;
            index = (originalIndex + i * i) % size;
            if (i >= size) {
                cout << "Hash table is full! Cannot insert " << key << endl;
                return;
            }
        }
        
        table[index] = key;
        occupied[index] = true;
        cout << "Inserted " << key << " at position " << index << " (probes: " << i << ")" << endl;
    }

    void display() {
        cout << "\nHash Table (Quadratic Probing):" << endl;
        cout << "Category\tNo of Mangoes\tIndex" << endl;
        for (int i = 0; i < size; i++) {
            cout << i + 1 << "\t\t";
            if (occupied[i]) {
                cout << table[i];
            } else {
                cout << "Empty";
            }
            cout << "\t\t" << i << endl;
        }
    }
};

int main() {
    HashTableQuadratic ht(11);
    
    cout << "=== Mango Varieties Hash Table (Quadratic Probing) ===" << endl;
    
    // Category 1-11 with number of mangoes
    int mangoes[] = {25, 15, 10, 5, 11, 19, 16, 36, 42, 28, 32};
    
    cout << "Category\tNo of Mangoes" << endl;
    for (int i = 0; i < 11; i++) {
        cout << i + 1 << "\t\t" << mangoes[i] << endl;
    }
    
    cout << "\nInserting into hash table:" << endl;
    for (int i = 0; i < 11; i++) {
        ht.insert(mangoes[i]);
    }
    
    ht.display();
    
    return 0;
}






#include <iostream>
#include <list>
#include <vector>
using namespace std;

class HashTableChaining {
private:
    vector<list<int>> table;
    int size;

public:
    HashTableChaining(int tableSize) {
        size = tableSize;
        table.resize(size);
    }

    int hashFunction(int key) {
        return key % 20;
    }

    void insert(int key) {
        int index = hashFunction(key);
        table[index].push_back(key);
        cout << "Inserted " << key << " at bucket " << index << endl;
    }

    void display() {
        cout << "\nHash table:" << endl;
        cout << "Index Values" << endl;
        for (int i = 0; i < size; i++) {
            cout << i << "\t";
            if (table[i].empty()) {
                cout << "Empty";
            } else {
                for (auto it = table[i].begin(); it != table[i].end(); ++it) {
                    cout << *it;
                    if (next(it) != table[i].end()) {
                        cout << " -> ";
                    }
                }
            }
            cout << endl;
        }
    }
};

int main() {
    HashTableChaining ht(20);
    
    cout << "Student marks hash table, separate chaining" << endl;
    
    int marks[] = {33, 56, 78, 12, 10, 67, 89, 99, 100, 23, 59, 90, 91, 20};
    int n = sizeof(marks) / sizeof(marks[0]);
    
    for (int i = 0; i < n; i++) {
        ht.insert(marks[i]);
    }
    
    ht.display();
    
    return 0;
}




